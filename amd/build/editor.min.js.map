{"version":3,"file":"editor.min.js","sources":["../src/editor.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * OUSupSub Editor Manager.\r\n *\r\n * @module editor_ousupsub/editor\r\n * @copyright  2024 The Open University.\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nconst defaultActions = {\r\n    sup: {\r\n        name: 'superscript',\r\n        tag: 'sup',\r\n        'class': 'ousupsub_superscript_button_superscript',\r\n    },\r\n    sub: {\r\n        name: 'subscript',\r\n        tag: 'sub',\r\n        'class': 'ousupsub_subscript_button_subscript',\r\n    },\r\n};\r\n\r\nclass OUSupSubEditor {\r\n\r\n    // The editor's initial default settings.\r\n    defaultSetting = {\r\n        element: '',\r\n        type: 'both',\r\n        classes: {\r\n            wrap: 'ousupsub-wrap',\r\n            editor: 'editor_ousupsub',\r\n            contentWrap: 'editor_ousupsub_content_wrap',\r\n            content: 'editor_ousupsub_content',\r\n            toolbar: 'editor_ousupsub_toolbar',\r\n            toolbarGroup: 'ousupsub_group',\r\n            button: 'ousupsub-button',\r\n        },\r\n        custom: {\r\n            editor: '',\r\n            content: '',\r\n            toolbar: '',\r\n            button: '',\r\n            contentWrap: '',\r\n            wrap: '',\r\n            toolbarGroup: '',\r\n        },\r\n    };\r\n\r\n    // Support for undo/redo with history data and history index.\r\n    history = [];\r\n    historyIndex = -1;\r\n\r\n    /**\r\n     * Constructor of the editor.\r\n     * @constructor\r\n     *\r\n     * @param {Object} settings - The editor settings.\r\n     */\r\n    constructor(settings) {\r\n        this.settings = Object.assign(this.defaultSetting, settings);\r\n        this.init();\r\n    }\r\n\r\n    /**\r\n     * Initial the editor.\r\n     */\r\n    init() {\r\n        const textareaElement = this.getTextArea();\r\n        const {classes, custom} = this.settings;\r\n\r\n        if (!textareaElement) {\r\n            return;\r\n        }\r\n        // Hidden origin text area.\r\n        textareaElement.style.display = 'none';\r\n\r\n        const editorElement = this.createElement('div', {\r\n            'class': (classes.editor + ' ' + (custom?.editor ?? '')).trim(),\r\n            id: classes.editor + '-' + this.settings.element,\r\n        });\r\n\r\n        // Make editor container.\r\n        const editorWrap = this.createElement('div', {\r\n            'class': (classes.wrap + ' ' + custom.wrap).trim(),\r\n        });\r\n\r\n        // Make toolbar containers.\r\n        const toolbarEl = this.initEditorToolbar();\r\n        this.appendChild(editorWrap, toolbarEl);\r\n\r\n        // Make the content for editor.\r\n        const contentElementWrap = this.initEditorContent();\r\n        const contentEditor = contentElementWrap.querySelector(`.${this.settings.classes.content}`);\r\n\r\n        // Append the editor's elements to the DOM.\r\n        this.appendChild(editorWrap, contentElementWrap);\r\n        this.appendChild(editorElement, editorWrap);\r\n\r\n        // Calculate the editor size based on the attributes 'cols' and 'rows'.\r\n        const width = (this.getTextArea().getAttribute('cols') * 6 + 41) + 'px';\r\n        contentEditor.style.width = width;\r\n        contentEditor.style.minWidth = width;\r\n        contentEditor.style.maxWidth = width;\r\n\r\n        const rows = this.getTextArea().getAttribute('rows');\r\n        const height = (rows * 6 + 13);\r\n        const heightEditor = `${height - 10}px`;\r\n        const lineHeightEditor = `${height - 6}px`;\r\n\r\n        // Set the size of the editor.\r\n        contentEditor.style.height = heightEditor;\r\n        contentEditor.style.minHeight = heightEditor;\r\n        contentEditor.style.maxHeight = heightEditor;\r\n        contentEditor.style.lineHeight = lineHeightEditor;\r\n\r\n        const heightContent = `${height + 1}px`;\r\n        contentElementWrap.style.minHeight = heightContent;\r\n\r\n        const textareaLabel = document.querySelector('[for=\"' + this.settings.element + '\"]');\r\n\r\n        textareaLabel.style.display = 'inline-block';\r\n        textareaLabel.style.margin = 0;\r\n        textareaLabel.style.height = heightContent;\r\n        textareaLabel.style.minHeight = heightContent;\r\n        textareaLabel.style.maxHeight = heightContent;\r\n\r\n        // Align for the case using Supsub on the editor.\r\n        if (textareaLabel.classList.contains('accesshide')) {\r\n            textareaLabel.classList.remove('accesshide');\r\n            textareaLabel.style.visibility = 'hidden';\r\n            editorElement.style.marginLeft = `-${parseInt(textareaLabel.offsetWidth)}px`;\r\n        } else {\r\n            // Get parent node of the label.\r\n            const labelParentNode = textareaLabel.parentNode;\r\n            labelParentNode.style.paddingBottom = heightEditor;\r\n            textareaLabel.style.verticalAlign = 'bottom';\r\n        }\r\n\r\n        textareaElement.insertAdjacentElement('beforebegin', editorElement);\r\n        // Set the editor's content for the first time.\r\n        this.getEditorContent().innerHTML = this.getContent();\r\n\r\n        // Save the history from the beginning.\r\n        this.saveHistory();\r\n\r\n        // Wait until the editor element is added to the DOM before calculating\r\n        // its size to ensure it aligns with the others elements.\r\n        requestAnimationFrame(() => {\r\n            textareaLabel.style.lineHeight = contentEditor.style.lineHeight;\r\n            const heightWrapper = height + 1 + parseInt(toolbarEl.offsetHeight);\r\n            editorElement.style.height = heightWrapper + 'px';\r\n            editorElement.style.minHeight = heightWrapper + 'px';\r\n            editorElement.style.maxHeight = heightWrapper + 'px';\r\n        });\r\n\r\n        document.addEventListener('click', (e) => {\r\n            if (!editorElement.contains(e.target)) {\r\n                // Get clean data.\r\n                const cleanData = this.getCleanHTML();\r\n                // Set it in both the hidden text area and the editor content.\r\n                this.getTextArea().value = cleanData;\r\n                this.getEditorContent().innerHTML = cleanData;\r\n                this.setActiveButton(false);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Make a content area for the editor.\r\n     *\r\n     * @return {HTMLElement} The content area element.\r\n     */\r\n    initEditorContent = () => {\r\n        const {classes, custom} = this.settings;\r\n        const contentElement = this.createElement('div', {\r\n            'class': (classes.content + ' ' + (custom.content ?? '')).trim(),\r\n            contenteditable: true,\r\n            autocapitalize: 'none',\r\n            autocorrect: 'off',\r\n            role: 'textbox',\r\n            spellcheck: false,\r\n            'aria-live': 'off',\r\n            id: `${this.settings.element.replace(/:/g, \":\")}editable`,\r\n        });\r\n\r\n        contentElement.addEventListener('blur', () => {\r\n            this.saveHistory();\r\n        });\r\n\r\n        // Listen for the selection change event.\r\n        document.addEventListener('selectionchange', () => this.handleSelectionChange());\r\n\r\n        // Set up hotkeys for the editor and prevent the Enter key from making the text content a single line.\r\n        contentElement.addEventListener('keydown', (event) => {\r\n            // Selection range.\r\n            const selection = window.getSelection();\r\n            const range = selection.getRangeAt(0);\r\n            const keyMap = {\r\n                key: {\r\n                    'ArrowUp': 'sup',\r\n                    '94': 'sup',\r\n                    'ArrowDown': 'sub',\r\n                    '95': 'sub',\r\n\r\n                },\r\n                shiftKey: {\r\n                    '^': 'sup',\r\n                    '_': 'sub',\r\n                }\r\n            };\r\n            if (keyMap.key[event.key] || (event.shiftKey && keyMap.shiftKey[event.key])) {\r\n                event.preventDefault();\r\n                this.handleSupSubHotKey(keyMap[event.key]);\r\n            }\r\n\r\n            if (event.ctrlKey) {\r\n                this.saveHistory();\r\n            }\r\n\r\n            if (event.key === 'Enter') {\r\n                event.preventDefault();\r\n            }\r\n\r\n            // Handle undo/redo action.\r\n            if (event.ctrlKey && event.key === 'z') {\r\n                event.preventDefault();\r\n                this.handleUndo();\r\n            }\r\n\r\n            if (event.ctrlKey && event.key === 'y') {\r\n                event.preventDefault();\r\n                this.handleRedo();\r\n            }\r\n\r\n            // In case the editor is empty we need to reset format\r\n            // to prevent it remember the previous format.\r\n            if (this.cleanHTML(event.target.innerHTML) === '' &&\r\n                    !this.isSelectionInsideSubSup()) {\r\n                const emptyText = document.createTextNode('\\uFEFF');\r\n                range.insertNode(emptyText);\r\n            }\r\n\r\n            this.getTextArea().value = this.getCleanHTML();\r\n        });\r\n\r\n        contentElement.addEventListener('paste', event => {\r\n            this.handlePaste(event);\r\n        });\r\n\r\n        const wrapContent = this.createElement('div', {\r\n            'class': (classes.contentWrap + ' ' + (custom.contentWrap ?? '')).trim(),\r\n        });\r\n\r\n        this.appendChild(wrapContent, contentElement);\r\n\r\n        return wrapContent;\r\n    };\r\n\r\n    /**\r\n     * Handle event paste.\r\n     *\r\n     * @param {Event} event Event object.\r\n     */\r\n    handlePaste(event) {\r\n        event.preventDefault();\r\n        const types = event.clipboardData.types;\r\n        let isHTML = false;\r\n\r\n        // Check for different methods to determine if 'text/html' is present\r\n        if (types?.contains) {\r\n            isHTML = types.contains('text/html');\r\n        } else if (types?.includes) {\r\n            isHTML = types.includes('text/html');\r\n        }\r\n\r\n        let content;\r\n        if (isHTML) {\r\n            content = this.cleanPasteHTML(event.clipboardData.getData('text/html'));\r\n        } else {\r\n            content = event.clipboardData.getData('text');\r\n        }\r\n\r\n        // We need to clean the data before inserting it into the editor.\r\n        const cleanData = content.replaceAll(/[\\r\\n]+/g, '');\r\n        document.execCommand('insertHTML', false, cleanData);\r\n        this.saveHistory();\r\n        this.getTextArea().value = this.getCleanHTML();\r\n    }\r\n\r\n    /**\r\n     * Handle event undo.\r\n     */\r\n    handleUndo() {\r\n        if (this.historyIndex > 0) {\r\n            this.historyIndex--;\r\n            this.getEditorContent().innerHTML = this.history[this.historyIndex];\r\n            this.getTextArea().value = this.history[this.historyIndex];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle event redo.\r\n     */\r\n    handleRedo() {\r\n        if (this.historyIndex < this.history.length - 1) {\r\n            this.historyIndex++;\r\n            this.getEditorContent().innerHTML = this.history[this.historyIndex];\r\n            this.getTextArea().value = this.history[this.historyIndex];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle event sup/sub.\r\n     *\r\n     * @param {String} action The sup/sub action.\r\n     */\r\n    handleSupSubHotKey(action) {\r\n        const nodeEl = this.isSelectionInsideSubSup();\r\n        if (nodeEl) {\r\n            const nodeName = nodeEl.nodeName.toLowerCase();\r\n            if (nodeName !== action) {\r\n                this.setFormat(this.getActions(nodeName === 'sup' ? 'sub' : 'sup')[0]);\r\n            }\r\n            return;\r\n        }\r\n        if (this.isSupportSupSub(action)) {\r\n            this.setFormat(this.getActions(action)[0]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Based on the user's selection change, we will detect the pointer position to determine whether\r\n     * the cursor is inside the sup/sub tag. Depending on this result, we will activate the corresponding button.\r\n     */\r\n    handleSelectionChange() {\r\n        const selection = window.getSelection();\r\n\r\n        // When the user makes a selection change inside the editor.\r\n        if (this.getEditorContent().contains(selection.anchorNode)) {\r\n            // Detect whether the pointer is inside the sup/sub tag.\r\n            const node = this.isSelectionInsideSubSup();\r\n\r\n            if (node) {\r\n                // Activate the corresponding button in the toolbar.\r\n                this.setActiveButton(node.nodeName.toLowerCase());\r\n            } else {\r\n                // Deactivate all the buttons.\r\n                this.setActiveButton(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utility function to create a element with attributes.\r\n     *\r\n     * @param {String} tag - HTML tag name.\r\n     * @param {Object} attributes - The attributes of the element, such as class, id, etc.\r\n     * @return {HTMLElement} The element that was created.\r\n     */\r\n    createElement(tag, attributes = {}) {\r\n        const element = document.createElement(tag);\r\n        for (let attribute in attributes) {\r\n            element.setAttribute(attribute, attributes[attribute]);\r\n        }\r\n\r\n        return element;\r\n    }\r\n\r\n    /**\r\n     * Utility function to check whether the current selection is inside the sup/sub tag. Returns false if it's not.\r\n     *\r\n     * @return {Boolean|ParentNode} Return the node if the selection is inside a sup/sub tag; otherwise, return false.\r\n     */\r\n    isSelectionInsideSubSup() {\r\n        const selection = window.getSelection();\r\n        if (selection.rangeCount === 0) {\r\n            return false;\r\n        }\r\n        const range = selection.getRangeAt(0);\r\n        const tagName = range.commonAncestorContainer.parentNode.nodeName;\r\n        // If user doesn't select any text.\r\n        if (selection.isCollapsed) {\r\n            if (this.isSupSubTag(tagName)) {\r\n                return range.commonAncestorContainer.parentNode;\r\n            }\r\n            return false;\r\n        }\r\n        let nodeNames;\r\n        const selectionNodes = range.cloneContents().childNodes;\r\n        for (let node of selectionNodes) {\r\n            const nodeName = node.nodeName;\r\n            if (node.textContent === '') {\r\n                continue;\r\n            }\r\n            if (!(this.isSupSubTag(nodeName)) &&\r\n                    (nodeName === '#text' && !this.isSupSubTag(tagName))) {\r\n                return false;\r\n            }\r\n            if (!nodeNames) {\r\n                nodeNames = node;\r\n            }\r\n            if (!nodeNames.isEqualNode(node)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (nodeNames.nodeName === '#text' || this.isSupSubTag(tagName)) {\r\n            return range.commonAncestorContainer.parentNode;\r\n        }\r\n\r\n        return nodeNames;\r\n    }\r\n\r\n    /**\r\n     * Check if the given tag name is 'sup' or 'sub'. Return true if it is.\r\n     *\r\n     * @param {String} tagName - Tag name need to check.\r\n     * @return {Boolean|ParentNode} Return the node if the selection is inside a sup/sub tag; otherwise, return false.\r\n     */\r\n    isSupSubTag(tagName) {\r\n        return ['SUB', 'SUP'].includes(tagName);\r\n    }\r\n\r\n    /**\r\n     * Utility function to highlight the sup/sub button.\r\n     *\r\n     * @param {String|Boolean} type - The type of the button: sup or sub.\r\n     */\r\n    setActiveButton(type) {\r\n        const {toolbar, button} = this.settings.classes;\r\n        // Deactivate all the existing buttons.\r\n        this.getEditor().querySelectorAll(`.${toolbar} .${button}`)\r\n            .forEach(button => button.classList.remove('highlight'));\r\n        if (type !== false) {\r\n            this.getSupSubButton(type)?.classList?.add('highlight');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utility function to append a child node to a parent node.\r\n     *\r\n     * @param {HTMLElement} parent - The parent node that will contain the child node.\r\n     * @param {HTMLElement} child - The child node.\r\n     */\r\n    appendChild(parent, child) {\r\n        parent.appendChild(child);\r\n    }\r\n\r\n    /**\r\n     * Utility function to create a toolbar element that contains sup and sub buttons.\r\n     *\r\n     * @return {HTMLElement} The toolbar element.\r\n     */\r\n    initEditorToolbar() {\r\n        const toolbarGroup = this.createElement('div', {\r\n            'class': (this.settings.classes.toolbarGroup + ' ' + (this.settings?.custom?.toolbarGroup ?? '')).trim(),\r\n        });\r\n        this.getActions(this.settings.type).forEach((action) => {\r\n            const button = this.createElement('button', {\r\n                'class': this.settings?.classes.button + ' ' + action.class,\r\n                title: this.settings.buttons[action.name].title,\r\n                type: 'button',\r\n                'data-action': action.name,\r\n            });\r\n\r\n            button.innerHTML = this.settings.buttons[action.name].icon;\r\n            button.setAttribute('type', 'button');\r\n            button.onclick = () => {\r\n                const selection = window.getSelection();\r\n                const nodeEl = this.isSelectionInsideSubSup();\r\n                if (selection.isCollapsed && nodeEl !== false) {\r\n                    if (nodeEl.nodeName.toLowerCase() !== action.tag) {\r\n                        button.blur();\r\n                        this.getEditorContent().focus();\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                this.getEditorContent().focus();\r\n                this.setFormat(action);\r\n            };\r\n\r\n            this.appendChild(toolbarGroup, button);\r\n        });\r\n        const toolbarEl = this.createElement('div', {\r\n            'class': (this.settings.classes.toolbar + ' ' + (this.settings?.custom?.toolbar ?? '')).trim(),\r\n        });\r\n        this.appendChild(toolbarEl, toolbarGroup);\r\n\r\n        return toolbarEl;\r\n    }\r\n\r\n    /**\r\n     * Based on the action (sup/sub), this function will format the selected text accordingly.\r\n     *\r\n     * @param {Object} action - The sup/sub action object.\r\n     */\r\n    setFormat(action) {\r\n        // Selection text.\r\n        const selection = window.getSelection();\r\n        // Selection range.\r\n        const range = selection.getRangeAt(0);\r\n        const {tag} = action;\r\n        const nodeEl = this.isSelectionInsideSubSup();\r\n        // In case the user doesn't select any text.\r\n        if (selection.isCollapsed) {\r\n            // We need to check whether the current position of the pointer is inside a sub or sup tag.\r\n            const parentNode = range.commonAncestorContainer.parentNode;\r\n            if (parentNode.nodeName.toLowerCase() === tag) {\r\n                // In this case, the pointer is inside a sub or sup tag, so we need to select all the text within the tag.\r\n                // Then, we will slice it into two parts, using the current position of the cursor as the border.\r\n                // The first part will extend from position 0 to the border, and the second part will span from\r\n                // the border to the end.\r\n                // After that, we will wrap each part in the corresponding sub or sup tag. The result will be:\r\n                // <sup>First</sup> and <sup>Second</sup>.\r\n                // Finally, we will create a text node with empty content (\\uFEFF) and place it at the border\r\n                // of the two parts, resulting in:\r\n                // <sup>First</sup>#textnode#<sup>Second</sup>.\r\n                // Create the first part.\r\n                const beforeText = this.createElement(tag);\r\n                beforeText.innerText = parentNode.textContent.slice(0, range.startOffset);\r\n                // Make an empty textnode.\r\n                const emptyText = document.createTextNode('\\uFEFF');\r\n                // Create an empty text node.\r\n                const afterText = this.createElement(tag);\r\n                afterText.innerText = parentNode.textContent.slice(range.startOffset);\r\n                // Insert it into the DOM next to the parent node.\r\n                if (afterText.innerHTML !== '') {\r\n                    parentNode.parentNode.insertBefore(afterText, parentNode.nextSibling);\r\n                }\r\n                parentNode.parentNode.insertBefore(emptyText, parentNode.nextSibling);\r\n                if (beforeText.innerHTML !== '') {\r\n                    parentNode.parentNode.insertBefore(beforeText, parentNode.nextSibling);\r\n                }\r\n\r\n                // Remove the parent node.\r\n                parentNode.remove();\r\n                // We set the position of the cursor to be in the empty text node.\r\n                range.setStart(emptyText, 1);\r\n                range.setEnd(emptyText, 1);\r\n                selection.removeAllRanges();\r\n                selection.addRange(range);\r\n            } else {\r\n                // In case the user didn't select anything, we must create a sup/sub\r\n                // tag with an empty string and move the cursor into it.\r\n                const node = this.createElement(tag);\r\n                // Zero-width space to keep the tag visible.\r\n                node.appendChild(document.createTextNode('\\uFEFF'));\r\n                // Update the new range within the existing one.\r\n                range.insertNode(node);\r\n                // Set the selection index at the next available space.\r\n                range.setStart(node.firstChild, 1);\r\n                range.setEnd(node.firstChild, 1);\r\n                // Remove all existing ranges from the selection.\r\n                selection.removeAllRanges();\r\n                // Add the updated range object to the current selection.\r\n                selection.addRange(range);\r\n            }\r\n        } else if (nodeEl) {\r\n            // This means the user is selecting some text that is inside the sub or sup tag.\r\n            // In this case, we only need to move the selected text inside the sub/sup tag outside of it.\r\n            // For example: <sup>123[456]789</sup>. If the selected text is 456, we will\r\n            // move it outside the <sup> tag, resulting in <sup>123</sup>456<sup>789</sup>.\r\n            // Retrieve the selected text.\r\n            // Retrieve the current tag (sub/sup) that wraps the selection\r\n            const selectedText = range.toString();\r\n            const parentElement = nodeEl;\r\n            const nextSibling = parentElement.nextSibling;\r\n            const beforeText = parentElement.textContent.slice(0, range.startOffset);\r\n            const afterText = parentElement.textContent.slice(range.endOffset);\r\n            if (beforeText) {\r\n                const start = this.createElement(parentElement.nodeName.toLowerCase());\r\n                start.textContent = beforeText;\r\n                parentElement.parentNode.insertBefore(start, nextSibling);\r\n            }\r\n            // Create a text node based on the selected text.\r\n            const textNode = document.createTextNode(selectedText);\r\n            parentElement.parentNode.insertBefore(textNode, nextSibling);\r\n            if (afterText) {\r\n                const end = this.createElement(parentElement.nodeName.toLowerCase());\r\n                end.textContent = afterText;\r\n                parentElement.parentNode.insertBefore(end, nextSibling);\r\n            }\r\n\r\n            parentElement.remove();\r\n\r\n            // Create a new range to select the inserted content\r\n            range.setStart(textNode, 0);\r\n            range.setEnd(textNode, selectedText.length);\r\n            selection.removeAllRanges();\r\n            selection.addRange(range);\r\n            this.getTextArea().value = this.getCleanHTML();\r\n        } else {\r\n            // This case is user select a text that is not inside subsup.\r\n            //  We retrieve the selected text and then delete it in DOM.\r\n            const selectedText = range.toString();\r\n            range.deleteContents();\r\n            const previousNode = range.commonAncestorContainer.previousSibling;\r\n            const nextNode = range.commonAncestorContainer.nextSibling;\r\n            // In addition, we will merge adjacent sup/sub tags into a single sup/sub tag.\r\n            if (previousNode || nextNode) {\r\n                const newNode = this.createElement(tag);\r\n                let startOffset = 0;\r\n                let endOffset = 0;\r\n                let content = '';\r\n                if (previousNode && previousNode?.nodeName?.toLowerCase() === tag) {\r\n                    content = previousNode.textContent;\r\n                    startOffset = content.length;\r\n                    previousNode.remove();\r\n                }\r\n                content += selectedText;\r\n                endOffset = content.length;\r\n                if (nextNode && nextNode?.nodeName?.toLowerCase() === tag) {\r\n                    content += nextNode.textContent;\r\n                    nextNode.remove();\r\n                }\r\n                newNode.textContent = content;\r\n                if (content !== selectedText) {\r\n                    range.insertNode(newNode);\r\n                    range.setStart(newNode.firstChild, startOffset);\r\n                    range.setEnd(newNode.firstChild, endOffset);\r\n                    this.getTextArea().value = this.getCleanHTML();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Create a sup/sub tag that wrap the selected text.\r\n            const newNode = document.createElement(tag);\r\n            newNode.appendChild(document.createTextNode(selectedText));\r\n            // Make a selection to the selected text.\r\n            selection.removeAllRanges();\r\n            // Insert it into DOM.\r\n            range.insertNode(newNode);\r\n            range.selectNodeContents(newNode.firstChild);\r\n            selection.addRange(range);\r\n            // Clean up all the empty text.\r\n            this.getEditorContent().childNodes.forEach(el => {\r\n                if (el.nodeName === '#text' && el.textContent === '') {\r\n                    el.remove();\r\n                }\r\n            });\r\n            this.getTextArea().value = this.getCleanHTML();\r\n        }\r\n        // Clean up.\r\n        this.getEditorContent().childNodes.forEach(el => {\r\n            if (el.nodeName === '#text' && el.textContent === '') {\r\n                el.remove();\r\n            }\r\n        });\r\n        this.saveHistory();\r\n    }\r\n\r\n    /**\r\n     * Save history for undo/redo actions.\r\n     */\r\n    saveHistory() {\r\n        const content = this.getCleanHTML();\r\n        if (this.historyIndex === -1 || content !== this.history[this.historyIndex]) {\r\n            this.history.splice(this.historyIndex + 1);\r\n            this.history.push(content);\r\n            this.historyIndex++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cleanup html that comes from WYSIWYG paste events. These are more likely to contain messy code that we should strip.\r\n     *\r\n     * @param {String} content - The content data need to be clean.\r\n     */\r\n    cleanPasteHTML(content) {\r\n        // Return an empty string if passed an invalid or empty object.\r\n        if (!content || content.length === 0) {\r\n            return \"\";\r\n        }\r\n\r\n        // Rules that get rid of the real-nasties and don't care about normalize code (correct quotes, white spaces, etc.).\r\n        let rules = [\r\n            {regex: /<\\s*\\/html\\s*>([\\s\\S]+)$/gi, replace: \"\"},\r\n            {regex: /<!--\\[if[\\s\\S]*?endif\\]-->/gi, replace: \"\"},\r\n            {regex: /<!--(Start|End)Fragment-->/gi, replace: \"\"},\r\n            {regex: /<xml[^>]*>[\\s\\S]*?<\\/xml>/gi, replace: \"\"},\r\n            {regex: /<\\?xml[^>]*>[\\s\\S]*?<\\\\\\?xml>/gi, replace: \"\"},\r\n            {regex: /<\\/?\\w+:[^>]*>/gi, replace: \"\"}\r\n        ];\r\n\r\n        // Apply the first set of harsher rules.\r\n        content = this.filterContentWithRules(content, rules);\r\n\r\n        // Apply the standard rules, which mainly cleans things like headers, links, and style blocks.\r\n        content = this.cleanHTML(content);\r\n\r\n        // Check if the string is empty or only contains whitespace.\r\n        if (content.length === 0 || !/\\S/.test(content)) {\r\n            return content;\r\n        }\r\n\r\n        // Normalize the code by loading it into the DOM.\r\n        const holder = document.createElement('div');\r\n        holder.innerHTML = content;\r\n        content = holder.innerHTML;\r\n\r\n        // Free up the DOM memory.\r\n        holder.innerHTML = \"\";\r\n\r\n        // Run some more rules that care about quotes and whitespace.\r\n        rules = [\r\n            {regex: /(<[^>]*?style\\s*?=\\s*?\"[^>\"]*?)(?:[\\s]*MSO[-:][^>;\"]*;?)+/gi, replace: \"$1\" },\r\n            {regex: /(<[^>]*?class\\s*?=\\s*?\"[^>\"]*?)(?:[\\s]*MSO[_a-zA-Z0-9\\-]*)+/gi, replace: \"$1\"},\r\n            {regex: /(<[^>]*?class\\s*?=\\s*?\"[^>\"]*?)(?:[\\s]*Apple-[_a-zA-Z0-9\\-]*)+/gi, replace: \"$1\"},\r\n            {regex: /<a [^>]*?name\\s*?=\\s*?\"OLE_LINK\\d*?\"[^>]*?>\\s*?<\\/a>/gi, replace: \"\"},\r\n        ];\r\n\r\n        // Apply the rules.\r\n        content = this.filterContentWithRules(content, rules);\r\n\r\n        // Reapply the standard cleaner to the content.\r\n        return this.cleanHTML(content);\r\n    }\r\n\r\n    /**\r\n     * Check if the editor allows the use of sub or sup features.\r\n     *\r\n     * @param {String} action - Sub/sup action to check.\r\n     * @return {Boolean} The result after verifying whether it is allowed.\r\n     */\r\n    isSupportSupSub(action) {\r\n        const {type} = this.settings;\r\n        return type === 'both' || type === action;\r\n    }\r\n\r\n    /**\r\n     * Utility function to filter the content based on the given rules.\r\n     *\r\n     * @param {String} content - The content need to be filtered.\r\n     * @param {Object} rules - The rules list.\r\n     * @return {String} The cleaned content will be returned.\r\n     */\r\n    filterContentWithRules(content, rules) {\r\n        for (const element of rules) {\r\n            content = content.replace(element.regex, element.replace);\r\n        }\r\n        return content;\r\n    }\r\n\r\n    /**\r\n     * Utility function to clean the HTML.\r\n     *\r\n     * @param {String} content - The content need to be filter.\r\n     * @return {String} The cleaned content will be returned.\r\n     */\r\n    cleanHTML(content) {\r\n        // Removing limited things that can break the page or a disallowed, like unclosed comments, style blocks, etc.\r\n\r\n        const rules = [\r\n            // Remove empty paragraphs.\r\n            {regex: /<p[^>]*>(&nbsp;|\\s)*<\\/p>/gi, replace: \"\"},\r\n\r\n            // Remove attributes on sup and sub tags.\r\n            {regex: /<sup[^>]*(&nbsp;|\\s)*>/gi, replace: \"<sup>\"},\r\n            {regex: /<sub[^>]*(&nbsp;|\\s)*>/gi, replace: \"<sub>\"},\r\n\r\n            //Replace &nbsp; with space.\r\n            {regex: /&nbsp;/gi, replace: \" \"},\r\n\r\n            // Combine matching tags with spaces in between.\r\n            {regex: /<\\/sup>(\\s*)+<sup>/gi, replace: \"$1\"},\r\n            {regex: /<\\/sub>(\\s*)+<sub>/gi, replace: \"$1\"},\r\n\r\n            // Move spaces after start sup and sub tags to before.\r\n            {regex: /<sup>(\\s*)+/gi, replace: \"$1<sup>\"},\r\n            {regex: /<sub>(\\s*)+/gi, replace: \"$1<sub>\"},\r\n\r\n            // Move spaces before end sup and sub tags to after.\r\n            {regex: /(\\s*)+<\\/sup>/gi, replace: \"</sup>$1\"},\r\n            {regex: /(\\s*)+<\\/sub>/gi, replace: \"</sub>$1\"},\r\n\r\n            // Remove empty br tags.\r\n            {regex: /<br>/gi, replace: \"\"},\r\n\r\n            // Remove any style blocks. Some browsers do not work well with them in a contenteditable.\r\n            // Plus style blocks are not allowed in body html, except with \"scoped\", which most browsers don't support as of 2015.\r\n            // Reference: \"http://stackoverflow.com/questions/1068280/javascript-regex-multiline-flag-doesnt-work\"\r\n            {regex: /<style[^>]*>[\\s\\S]*?<\\/style>/gi, replace: \"\"},\r\n\r\n            // Remove any open HTML comment opens that are not followed by a close. This can completely break page layout.\r\n            {regex: /<!--(?![\\s\\S]*?-->)/gi, replace: \"\"},\r\n\r\n            // Remove elements that can not contain visible text.\r\n            {regex: /<script[^>]*>[\\s\\S]*?<\\/script>/gi, replace: \"\"},\r\n\r\n            // Source: \"http://www.codinghorror.com/blog/2006/01/cleaning-words-nasty-html.html\"\r\n            // Remove forbidden tags for content, title, meta, style, st0-9, head, font, html, body, link.\r\n            {regex: /<\\/?(?:br|title|meta|style|std|font|html|body|link|a|ul|li|ol)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:b|i|u|ul|ol|li|img)[^>]*?>/gi, replace: \"\"},\r\n            // Source:\"https://developer.mozilla.org/en/docs/Web/HTML/Element\"\r\n            // Remove all elements except sup and sub.\r\n            {regex: /<\\/?(?:abbr|address|area|article|aside|audio|base|bdi|bdo|blockquote)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:button|canvas|caption|cite|code|col|colgroup|content|data)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:datalist|dd|decorator|del|details|dialog|dfn|div|dl|dt|element)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:em|embed|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:h6|header|hgroup|hr|iframe|input|ins|kbd|keygen|label|legend)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:main|map|mark|menu|menuitem|meter|nav|noscript|object|optgroup)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:option|output|p|param|pre|progress|q|rp|rt|rtc|ruby|samp)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:section|select|script|shadow|small|source|std|strong|summary)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:svg|table|tbody|td|template|textarea|time|tfoot|th|thead|tr|track)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:var|wbr|video)[^>]*?>/gi, replace: \"\" },\r\n\r\n            // Deprecated elements that might still be used by older sites.\r\n            {regex: /<\\/?(?:acronym|applet|basefont|big|blink|center|dir|frame|frameset|isindex)[^>]*?>/gi, replace: \"\"},\r\n            {regex: /<\\/?(?:listing|noembed|plaintext|spacer|strike|tt|xmp)[^>]*?>/gi, replace: \"\"},\r\n\r\n            // Elements from common sites including google.com.\r\n            {regex: /<\\/?(?:jsl|nobr)[^>]*?>/gi, replace: \"\"},\r\n\r\n            {regex: /<span(?![^>]*?rangySelectionBoundary[^>]*?)[^>]*>[\\s\\S]*?([\\s\\S]*?)<\\/span>/gi, replace: \"$1\"},\r\n\r\n            // Remove empty spans, but not ones from Rangy.\r\n            {regex: /<span(?![^>]*?rangySelectionBoundary[^>]*?)[^>]*>(&nbsp;|\\s)*<\\/span>/gi, replace: \"\"},\r\n            {regex: /<span(?![^>]*?rangySelectionBoundary[^>]*?)[^>]*>[\\s\\S]*?([\\s\\S]*?)<\\/span>/gi, replace: \"$1\"},\r\n\r\n            // Remove empty sup and sub tags that appear after pasting text.\r\n            {regex: /<sup[^>]*>(&nbsp;|\\s)*<\\/sup>/gi, replace: \"\"},\r\n            {regex: /<sub[^>]*>(&nbsp;|\\s)*<\\/sub>/gi, replace: \"\"},\r\n\r\n            // Remove special xml namespace tag xmlns generate by browser plugin.\r\n            {regex: /<xmlns.*?>(.*?)<\\/xmlns.*?>/gi, replace: \"$1\"},\r\n            {regex: /\\uFEFF/gi, replace: \"\"}\r\n        ];\r\n\r\n        return this.filterContentWithRules(content, rules);\r\n    }\r\n\r\n    /**\r\n     * Clean the generated HTML content without modifying the editor content.\r\n     *\r\n     * This includes removing all YUI IDs from the generated content.\r\n     *\r\n     * @return {string} The cleaned HTML content.\r\n     */\r\n    getCleanHTML() {\r\n        // Clone the editor so that we don't actually modify the real content.\r\n        const editorClone = this.getEditorContent().cloneNode(true);\r\n        let html;\r\n\r\n        html = editorClone.innerHTML;\r\n\r\n        // Define contents that are considered empty.\r\n        const emptyContents = [\r\n            '<p></p>',\r\n            '<p><br></p>',\r\n            '<br>',\r\n            '<p dir=\"rtl\" style=\"text-align: right;\"></p>',\r\n            '<p dir=\"rtl\" style=\"text-align: right;\"><br></p>',\r\n            '<p dir=\"ltr\" style=\"text-align: left;\"></p>',\r\n            '<p dir=\"ltr\" style=\"text-align: left;\"><br></p>',\r\n            '<p>&nbsp;</p>',\r\n            '<p><br>&nbsp;</p>',\r\n            '<p dir=\"rtl\" style=\"text-align: right;\">&nbsp;</p>',\r\n            '<p dir=\"rtl\" style=\"text-align: right;\"><br>&nbsp;</p>',\r\n            '<p dir=\"ltr\" style=\"text-align: left;\">&nbsp;</p>',\r\n            '<p dir=\"ltr\" style=\"text-align: left;\"><br>&nbsp;</p>'\r\n        ];\r\n\r\n        if (emptyContents.includes(html)) {\r\n            return '';\r\n        }\r\n\r\n        // Clean the HTML content.\r\n        return this.cleanHTML(html);\r\n    }\r\n\r\n\r\n    /**\r\n     * Utility function to get the content element of the editor.\r\n     *\r\n     * @return {HTMLElement} The editor content element.\r\n     */\r\n    getEditorContent() {\r\n        return this.getEditor().querySelector(`.${this.settings.classes.content}`);\r\n    }\r\n\r\n    /**\r\n     * Utility function to get the editor element. This element will contain all the components of the editor.\r\n     *\r\n     * @return {HTMLElement} The editor element.\r\n     */\r\n    getEditor() {\r\n        return document.getElementById(`${this.settings.classes.editor}-${this.settings.element}`);\r\n    }\r\n\r\n    /**\r\n     * Utility function to retrieve the button element based on the given type.\r\n     *\r\n     * @param {String} type - The type of the button: sup or sub.\r\n     * @return {HTMLElement} The corresponding button.\r\n     */\r\n    getSupSubButton(type) {\r\n        const {toolbar, button} = this.settings.classes;\r\n        return this.getEditor().querySelector(`.${toolbar} .${button}[data-action^=\"${type}\"]`);\r\n    }\r\n\r\n    /**\r\n     * Utility function to get button settings (sup/sub) based on the given type.\r\n     *\r\n     * @param {String} type - The type of the button can be either sup or sub.\r\n     * @return {Object} The settings for the given button.\r\n     */\r\n    getActions(type) {\r\n        if (defaultActions[type]) {\r\n            return [defaultActions[type]];\r\n        }\r\n\r\n        return Object.values(defaultActions);\r\n    }\r\n\r\n    /**\r\n     * Utility to get the button container for the editor.\r\n     *\r\n     * @return {HTMLElement} The button container.\r\n     */\r\n    getButtonContainer() {\r\n        return this.getEditor().querySelectorAll(`.${this.settings.classes.toolbar} .${this.settings.classes.button}`);\r\n    }\r\n\r\n    /**\r\n     * Utility function to get the content of the original textarea.\r\n     *\r\n     * @return {String} The content.\r\n     */\r\n    getContent() {\r\n        return this.getTextArea().value;\r\n    }\r\n\r\n    /**\r\n     * Utility function to get id of the element.\r\n     *\r\n     * @return {String} The element id.\r\n     */\r\n    getEditorId() {\r\n        return this.settings.element;\r\n    }\r\n\r\n    /**\r\n     * Return the text area element.\r\n     *\r\n     * @return {HTMLElement} Text area element.\r\n     */\r\n    getTextArea() {\r\n        return document.getElementById(this.settings.element);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Load editor based on the given setting.\r\n *\r\n * @param {Object} settings - The editor setting.\r\n */\r\nexport const loadEditor = settings => {\r\n    const editor = new OUSupSubEditor(settings);\r\n    // We need to do this for a specific reason, currently only for the Behat test.\r\n    // We can easily utilize the editor's API.\r\n    if (!window.OUSupSubEditor) {\r\n        window.OUSupSubEditor = {\r\n            instances: {\r\n                [settings.element]: editor,\r\n            },\r\n            addEditor: function(editor) {\r\n                this.instances[editor.getEditorId()] = editor;\r\n            },\r\n            getEditorById: function(editorId) {\r\n                return this.instances[editorId];\r\n            },\r\n        };\r\n    } else {\r\n        window.OUSupSubEditor.addEditor(editor);\r\n    }\r\n};\r\n"],"names":["defaultActions","sup","name","tag","sub","OUSupSubEditor","constructor","settings","element","type","classes","wrap","editor","contentWrap","content","toolbar","toolbarGroup","button","custom","this","contentElement","createElement","trim","contenteditable","autocapitalize","autocorrect","role","spellcheck","id","replace","addEventListener","saveHistory","document","handleSelectionChange","event","range","window","getSelection","getRangeAt","keyMap","key","shiftKey","preventDefault","handleSupSubHotKey","ctrlKey","handleUndo","handleRedo","cleanHTML","target","innerHTML","isSelectionInsideSubSup","emptyText","createTextNode","insertNode","getTextArea","value","getCleanHTML","handlePaste","wrapContent","appendChild","Object","assign","defaultSetting","init","textareaElement","style","display","editorElement","editorWrap","toolbarEl","initEditorToolbar","contentElementWrap","initEditorContent","contentEditor","querySelector","width","getAttribute","minWidth","maxWidth","height","heightEditor","lineHeightEditor","minHeight","maxHeight","lineHeight","heightContent","textareaLabel","margin","classList","contains","remove","visibility","marginLeft","parseInt","offsetWidth","parentNode","paddingBottom","verticalAlign","insertAdjacentElement","getEditorContent","getContent","requestAnimationFrame","heightWrapper","offsetHeight","e","cleanData","setActiveButton","types","clipboardData","isHTML","includes","cleanPasteHTML","getData","replaceAll","execCommand","historyIndex","history","length","action","nodeEl","nodeName","toLowerCase","setFormat","getActions","isSupportSupSub","selection","anchorNode","node","attributes","attribute","setAttribute","rangeCount","tagName","commonAncestorContainer","isCollapsed","isSupSubTag","nodeNames","selectionNodes","cloneContents","childNodes","textContent","isEqualNode","getEditor","querySelectorAll","forEach","getSupSubButton","add","parent","child","_this$settings","_this$settings$custom2","class","title","buttons","icon","onclick","blur","focus","_this$settings3","_this$settings3$custo","beforeText","innerText","slice","startOffset","afterText","insertBefore","nextSibling","setStart","setEnd","removeAllRanges","addRange","firstChild","selectedText","toString","parentElement","endOffset","start","textNode","end","deleteContents","previousNode","previousSibling","nextNode","newNode","selectNodeContents","el","splice","push","rules","regex","filterContentWithRules","test","holder","html","cloneNode","getElementById","values","getButtonContainer","getEditorId","addEditor","instances","getEditorById","editorId"],"mappings":"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"}