{"version":3,"file":"editor.min.js","sources":["../src/editor.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * OUSupSub Editor Manager.\r\n *\r\n * @module editor_ousupsub/editor\r\n * @copyright  2024 The Open University.\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nconst defaultActions = {\r\n    sup: {\r\n        name: 'superscript',\r\n        tag: 'sup',\r\n        class: 'ousupsub_superscript_button_superscript',\r\n    },\r\n    sub: {\r\n        name: 'subscript',\r\n        tag: 'sub',\r\n        class: 'ousupsub_subscript_button_subscript',\r\n    },\r\n};\r\n\r\nclass OUSupSubEditor {\r\n\r\n    // The editor's initial default settings.\r\n    defaultSetting = {\r\n        element: '',\r\n        type: 'both',\r\n        classes: {\r\n            wrap: 'ousupsub-wrap',\r\n            editor: 'editor_ousupsub',\r\n            contentWrap: 'editor_ousupsub_content_wrap',\r\n            content: 'editor_ousupsub_content',\r\n            toolbar: 'editor_ousupsub_toolbar',\r\n            toolbarGroup: 'ousupsub_group',\r\n            button: 'ousupsub-button',\r\n        },\r\n        custom: {\r\n            editor: 'con cu',\r\n            content: '',\r\n            toolbar: '',\r\n            button: '',\r\n            contentWrap: '',\r\n            wrap: '',\r\n            toolbarGroup: '',\r\n        },\r\n    };\r\n\r\n    // Support for undo/redo with history data and history index.\r\n    history = [];\r\n    historyIndex = -1;\r\n\r\n    /**\r\n     * Constructor of the editor.\r\n     * @constructor\r\n     *\r\n     * @param {Object} settings - The editor settings.\r\n     */\r\n    constructor(settings) {\r\n        this.settings = Object.assign(this.defaultSetting, settings);\r\n        this.init();\r\n    }\r\n\r\n    /**\r\n     * Initial the editor.\r\n     */\r\n    init() {\r\n        const textareaElement = this.getTextArea();\r\n        const { classes, custom } = this.settings;\r\n\r\n        if (!textareaElement) {\r\n            return;\r\n        }\r\n        // Hidden origin text area.\r\n        textareaElement.style.display = 'none';\r\n\r\n        const editorElement = this.createElement('div', {\r\n            'class': (classes.editor + ' ' + (custom?.editor ?? '')).trim(),\r\n            id: classes.editor + '-' + this.settings.element,\r\n        });\r\n\r\n        // Make editor container.\r\n        const editorWrap = this.createElement('div', {\r\n            'class': (classes.wrap + ' ' + custom.wrap).trim(),\r\n        });\r\n\r\n        // Make toolbar containers.\r\n        const toolbarEl = this.initEditorToolbar();\r\n        this.appendChild(editorWrap, toolbarEl);\r\n\r\n        // Make the content for editor.\r\n        const contentElementWrap = this.initEditorContent();\r\n        const contentEditor = contentElementWrap.querySelector(`.${this.settings.classes.content}`);\r\n\r\n        // Append the editor's elements to the DOM.\r\n        this.appendChild(editorWrap, contentElementWrap);\r\n        this.appendChild(editorElement, editorWrap);\r\n\r\n        // Calculate the editor size based on the attributes 'cols' and 'rows'.\r\n        const width = (this.getTextArea().getAttribute('cols') * 6 + 41) + 'px';\r\n        contentEditor.style.width = width;\r\n        contentEditor.style.minWidth = width;\r\n        contentEditor.style.maxWidth = width;\r\n\r\n        const rows = this.getTextArea().getAttribute('rows');\r\n        const height = (rows * 6 + 13);\r\n        const heightEditor = `${height - 10}px`;\r\n        const lineHeightEditor = `${height - 6}px`;\r\n\r\n        // Set the size of the editor.\r\n        contentEditor.style.height = heightEditor;\r\n        contentEditor.style.minHeight = heightEditor;\r\n        contentEditor.style.maxHeight = heightEditor;\r\n        contentEditor.style.lineHeight = lineHeightEditor;\r\n\r\n        const heightContent = `${height + 1}px`;\r\n        contentElementWrap.style.minHeight = heightContent;\r\n\r\n        const textareaLabel = document.querySelector('[for=\"' + this.settings.element + '\"]');\r\n\r\n        textareaLabel.style.display = 'inline-block';\r\n        textareaLabel.style.margin = 0;\r\n        textareaLabel.style.height = heightContent;\r\n        textareaLabel.style.minHeight = heightContent;\r\n        textareaLabel.style.maxHeight = heightContent;\r\n\r\n        // Align for the case using Supsub on the editor.\r\n        if (textareaLabel.classList.contains('accesshide')) {\r\n            textareaLabel.classList.remove('accesshide');\r\n            textareaLabel.style.visibility = 'hidden';\r\n            editorElement.style.marginLeft = `-${parseInt(textareaLabel.offsetWidth)}px`;\r\n        } else {\r\n            // Get parent node of the label.\r\n            const labelParentNode = textareaLabel.parentNode;\r\n            labelParentNode.style.paddingBottom = heightEditor;\r\n            textareaLabel.style.verticalAlign = 'bottom';\r\n        }\r\n\r\n        textareaElement.insertAdjacentElement('beforebegin', editorElement);\r\n        // Set the editor's content for the first time.\r\n        this.getEditorContent().innerHTML = this.getContent();\r\n\r\n        // Save the history from the beginning.\r\n        this.saveHistory();\r\n\r\n        // Wait until the editor element is added to the DOM before calculating\r\n        // its size to ensure it aligns with the others elements.\r\n        requestAnimationFrame(() => {\r\n            textareaLabel.style.lineHeight = contentEditor.style.lineHeight;\r\n            const heightWrapper = height + 1 + parseInt(toolbarEl.offsetHeight);\r\n            editorElement.style.height = heightWrapper + 'px';\r\n            editorElement.style.minHeight = heightWrapper + 'px';\r\n            editorElement.style.maxHeight = heightWrapper + 'px';\r\n        });\r\n\r\n        document.addEventListener('click', (e) => {\r\n            if (!editorElement.contains(e.target)) {\r\n                // Get clean data.\r\n                const cleanData = this.getCleanHTML();\r\n                // Set it in both the hidden text area and the editor content.\r\n                this.getTextArea().value = cleanData;\r\n                this.getEditorContent().innerHTML = cleanData;\r\n                this.setActiveButton(false);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Make a content area for the editor.\r\n     *\r\n     * @return {HTMLElement} The content area element.\r\n     */\r\n    initEditorContent = () => {\r\n        // Based on the user's selection change, we will detect the pointer position to determine whether\r\n        // the cursor is inside the sup/sub tag.\r\n        // Depending on this result, we will activate the corresponding button.\r\n        document.addEventListener('selectionchange', () => {\r\n            const selection = window.getSelection();\r\n            // When the user makes a selection change inside the editor.\r\n            if (this.getEditorContent().contains(selection.anchorNode)) {\r\n                // Detect whether the pointer is inside the sup/sub tag.\r\n                // If inside the sub/sup tag, we will receive that node.\r\n                const node = this.isSelectionInsideSubSup();\r\n                if (node) {\r\n                    // Activate the corresponding button in the toolbar.\r\n                    this.setActiveButton(node.nodeName.toLowerCase());\r\n                } else {\r\n                    // Deactivate all the buttons.\r\n                    this.setActiveButton(false);\r\n                }\r\n            }\r\n        });\r\n\r\n        const { classes, custom } = this.settings;\r\n        const contentElement = this.createElement('div', {\r\n            'class': (classes.content + ' ' + (custom.content ?? '')).trim(),\r\n            contenteditable: true,\r\n            autocapitalize: 'none',\r\n            autocorrect: 'off',\r\n            role: 'textbox',\r\n            spellcheck: false,\r\n            'aria-live': 'off',\r\n            id: `${this.settings.element.replace(/:/g, \":\")}editable`,\r\n        });\r\n\r\n        contentElement.addEventListener('blur', (event) => {\r\n            this.saveHistory();\r\n        })\r\n\r\n        // Set up hotkeys for the editor and prevent the Enter key from making the text content a single line.\r\n        contentElement.addEventListener('keydown', (event) => {\r\n            // Selection range.\r\n            const selection = window.getSelection();\r\n            const range = selection.getRangeAt(0);\r\n            // When the user uses the sup hotkey.\r\n            if (event.key === 'ArrowUp' || (event.key === '94')\r\n                    || (event.shiftKey && event.key === '^')) {\r\n                event.preventDefault();\r\n                const action = 'sup';\r\n                const nodeEl = this.isSelectionInsideSubSup();\r\n                if (nodeEl) {\r\n                    if (nodeEl.nodeName.toLowerCase() !== action) {\r\n                        this.setFormat(this.getActions('sub')[0]);\r\n                    }\r\n                    return;\r\n                }\r\n                if (this.isSupportSupSub('sup')) {\r\n                    this.setFormat(this.getActions('sup')[0]);\r\n                }\r\n            } else if (event.key === 'ArrowDown' || (event.shiftKey && event.key === '_')\r\n                    || (event.key === '95')) {\r\n                event.preventDefault();\r\n                // The same behavior applies to subscript.\r\n                const action = 'sub';\r\n                const nodeEl = this.isSelectionInsideSubSup();\r\n                if (nodeEl) {\r\n                    if (nodeEl.nodeName.toLowerCase() !== action) {\r\n                        this.setFormat(this.getActions('sup')[0]);\r\n                    }\r\n                    return;\r\n                }\r\n                if (this.isSupportSupSub('sub')) {\r\n                    this.setFormat(this.getActions('sub')[0]);\r\n                }\r\n            }\r\n\r\n            if (event.ctrlKey) {\r\n                this.saveHistory();\r\n            }\r\n\r\n            if (event.key === 'Enter') {\r\n                event.preventDefault();\r\n            }\r\n\r\n            // Handle undo/redo action.\r\n            if (event.ctrlKey && event.key === 'z') {\r\n                event.preventDefault();\r\n                if (this.historyIndex > 0) {\r\n                    this.historyIndex--;\r\n                    this.getEditorContent().innerHTML = this.history[this.historyIndex];\r\n                    this.getTextArea().value = this.history[this.historyIndex];\r\n                }\r\n            }\r\n\r\n            if (event.ctrlKey && event.key === 'y') {\r\n                event.preventDefault();\r\n                if (this.historyIndex < this.history.length - 1) {\r\n                    this.historyIndex++;\r\n                    this.getEditorContent().innerHTML = this.history[this.historyIndex];\r\n                    this.getTextArea().value = this.history[this.historyIndex];\r\n                }\r\n            }\r\n\r\n            // In case the editor is empty we need to reset format\r\n            // to prevent it remember the previous format.\r\n            if (this.cleanHTML(event.target.innerHTML) === '' &&\r\n                !this.isSelectionInsideSubSup()) {\r\n                const emptyText = document.createTextNode('\\uFEFF');\r\n                range.insertNode(emptyText);\r\n            }\r\n\r\n            this.getTextArea().value = this.getCleanHTML();\r\n        });\r\n\r\n        contentElement.addEventListener('paste', event => {\r\n            event.preventDefault();\r\n            const types = event.clipboardData.types;\r\n            let isHTML = false;\r\n\r\n            // Check for different methods to determine if 'text/html' is present\r\n            if (types?.contains) {\r\n                isHTML = types.contains('text/html');\r\n            } else if (types?.includes) {\r\n                isHTML = types.includes('text/html');\r\n            }\r\n\r\n            let content;\r\n            if (isHTML) {\r\n                content = this.cleanPasteHTML(event.clipboardData.getData('text/html'));\r\n            } else {\r\n                content = event.clipboardData.getData('text');\r\n            }\r\n\r\n            // We need to clean the data before inserting it into the editor.\r\n            const cleanData = content.replaceAll(/[\\r\\n]+/g, '');\r\n            document.execCommand('insertHTML', false, cleanData);\r\n            this.saveHistory();\r\n            this.getTextArea().value = this.getCleanHTML();\r\n        });\r\n\r\n        const wrapContent = this.createElement('div', {\r\n            'class': (classes.contentWrap + ' ' + (custom.contentWrap ?? '')).trim(),\r\n        });\r\n\r\n        this.appendChild(wrapContent, contentElement);\r\n\r\n        return wrapContent;\r\n    };\r\n\r\n    /**\r\n     * Utility function to create a element with attributes.\r\n     *\r\n     * @param {String} tag - HTML tag name.\r\n     * @param {Object} attributes - The attributes of the element, such as class, id, etc.\r\n     * @return {HTMLElement} The element that was created.\r\n     */\r\n    createElement(tag, attributes = {}) {\r\n        const element = document.createElement(tag);\r\n        for (let attribute in attributes) {\r\n            element.setAttribute(attribute, attributes[attribute]);\r\n        }\r\n\r\n        return element;\r\n    }\r\n\r\n    /**\r\n     * Utility function to check whether the current selection is inside the sup/sub tag. Returns false if it's not.\r\n     *\r\n     * @return {Boolean|ParentNode} Return the node if the selection is inside a sup/sub tag; otherwise, return false.\r\n     */\r\n    isSelectionInsideSubSup() {\r\n        const selection = window.getSelection();\r\n        if (selection.rangeCount === 0) {\r\n            return false;\r\n        }\r\n        const range = selection.getRangeAt(0);\r\n        const tagName = range.commonAncestorContainer.parentNode.nodeName;\r\n        // If user doesn't select any text.\r\n        if (selection.isCollapsed) {\r\n            if (this.isSupSubTag(tagName)) {\r\n                return range.commonAncestorContainer.parentNode;\r\n            }\r\n            return false;\r\n        }\r\n        let nodeNames;\r\n        const selectionNodes = range.cloneContents().childNodes;\r\n        for (let node of selectionNodes) {\r\n            const nodeName = node.nodeName;\r\n            if (node.textContent === '') {\r\n                continue;\r\n            }\r\n            if (!(this.isSupSubTag(nodeName)) &&\r\n                    (nodeName === '#text' && !this.isSupSubTag(tagName))) {\r\n                return false;\r\n            }\r\n            if (!nodeNames) {\r\n                nodeNames = node;\r\n            }\r\n            if (!nodeNames.isEqualNode(node)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (nodeNames.nodeName === '#text' || this.isSupSubTag(tagName)) {\r\n            return range.commonAncestorContainer.parentNode;\r\n        }\r\n\r\n        return nodeNames;\r\n    }\r\n\r\n    /**\r\n     * Check if the given tag name is 'sup' or 'sub'. Return true if it is.\r\n     *\r\n     * @param {String} tagName - Tag name need to check.\r\n     * @return {Boolean|ParentNode} Return the node if the selection is inside a sup/sub tag; otherwise, return false.\r\n     */\r\n    isSupSubTag(tagName) {\r\n        return ['SUB', 'SUP'].includes(tagName);\r\n    }\r\n\r\n    /**\r\n     * Utility function to highlight the sup/sub button.\r\n     *\r\n     * @param {String|Boolean} type - The type of the button: sup or sub.\r\n     */\r\n    setActiveButton(type) {\r\n        const { toolbar, button } = this.settings.classes;\r\n        // Deactivate all the existing buttons.\r\n        this.getEditor().querySelectorAll(`.${toolbar} .${button}`)\r\n            .forEach(button => button.classList.remove('highlight'));\r\n        if (type !== false) {\r\n            this.getSupSubButton(type)?.classList?.add('highlight');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utility function to append a child node to a parent node.\r\n     *\r\n     * @param {HTMLElement} parent - The parent node that will contain the child node.\r\n     * @param {HTMLElement} child - The child node.\r\n     */\r\n    appendChild(parent, child) {\r\n        parent.appendChild(child);\r\n    }\r\n\r\n    /**\r\n     * Utility function to create a toolbar element that contains sup and sub buttons.\r\n     *\r\n     * @return {HTMLElement} The toolbar element.\r\n     */\r\n    initEditorToolbar() {\r\n        const toolbarGroup = this.createElement('div', {\r\n            'class': (this.settings.classes.toolbarGroup + ' ' + (this.settings?.custom?.toolbarGroup ?? '')).trim(),\r\n        });\r\n        this.getActions(this.settings.type).forEach((action) => {\r\n            const button = this.createElement('button', {\r\n                'class': this.settings?.classes.button + ' ' + action.class,\r\n                title: this.settings.buttons[action.name].title,\r\n                type: 'button',\r\n                'data-action': action.name,\r\n            });\r\n\r\n            button.innerHTML = this.settings.buttons[action.name].icon;\r\n            button.setAttribute('type', 'button');\r\n            button.onclick = (event) => {\r\n                const selection = window.getSelection();\r\n                const nodeEl = this.isSelectionInsideSubSup();\r\n                if (selection.isCollapsed && nodeEl !== false) {\r\n                    if (nodeEl.nodeName.toLowerCase() !== action.tag) {\r\n                        button.blur();\r\n                        this.getEditorContent().focus();\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                this.getEditorContent().focus();\r\n                this.setFormat(action);\r\n            };\r\n\r\n            this.appendChild(toolbarGroup, button);\r\n        });\r\n        const toolbarEl = this.createElement('div', {\r\n            'class': (this.settings.classes.toolbar + ' ' + (this.settings?.custom?.toolbar ?? '')).trim(),\r\n        });\r\n        this.appendChild(toolbarEl, toolbarGroup);\r\n\r\n        return toolbarEl;\r\n    }\r\n\r\n    /**\r\n     * Based on the action (sup/sub), this function will format the selected text accordingly.\r\n     *\r\n     * @param {Object} action - The sup/sub action object.\r\n     */\r\n    setFormat(action) {\r\n        // Selection text.\r\n        const selection = window.getSelection();\r\n        // Selection range.\r\n        const range = selection.getRangeAt(0);\r\n        const { tag } = action;\r\n        const nodeEl = this.isSelectionInsideSubSup();\r\n        // In case the user doesn't select any text.\r\n        if (selection.isCollapsed) {\r\n            // We need to check whether the current position of the pointer is inside a sub or sup tag.\r\n            const parentNode = range.commonAncestorContainer.parentNode;\r\n            if (parentNode.nodeName.toLowerCase() === tag) {\r\n                // In this case, the pointer is inside a sub or sup tag, so we need to select all the text within the tag.\r\n                // Then, we will slice it into two parts, using the current position of the cursor as the border.\r\n                // The first part will extend from position 0 to the border, and the second part will span from\r\n                // the border to the end.\r\n                // After that, we will wrap each part in the corresponding sub or sup tag. The result will be:\r\n                // <sup>First</sup> and <sup>Second</sup>.\r\n                // Finally, we will create a text node with empty content (\\uFEFF) and place it at the border\r\n                // of the two parts, resulting in:\r\n                // <sup>First</sup>#textnode#<sup>Second</sup>.\r\n                // Create the first part.\r\n                const beforeText = this.createElement(tag);\r\n                beforeText.innerText = parentNode.textContent.slice(0, range.startOffset);\r\n                // Make an empty textnode.\r\n                const emptyText = document.createTextNode('\\uFEFF');\r\n                // Create an empty text node.\r\n                const afterText = this.createElement(tag);\r\n                afterText.innerText = parentNode.textContent.slice(range.startOffset);\r\n                // Insert it into the DOM next to the parent node.\r\n                if (afterText.innerHTML !== '') {\r\n                    parentNode.parentNode.insertBefore(afterText, parentNode.nextSibling);\r\n                }\r\n                parentNode.parentNode.insertBefore(emptyText, parentNode.nextSibling);\r\n                if (beforeText.innerHTML !== '') {\r\n                    parentNode.parentNode.insertBefore(beforeText, parentNode.nextSibling);\r\n                }\r\n\r\n                // Remove the parent node.\r\n                parentNode.remove();\r\n                // We set the position of the cursor to be in the empty text node.\r\n                range.setStart(emptyText, 1);\r\n                range.setEnd(emptyText, 1);\r\n                selection.removeAllRanges();\r\n                selection.addRange(range);\r\n            } else {\r\n                // In case the user didn't select anything, we must create a sup/sub\r\n                // tag with an empty string and move the cursor into it.\r\n                const node = this.createElement(tag);\r\n                // Zero-width space to keep the tag visible.\r\n                node.appendChild(document.createTextNode('\\uFEFF'));\r\n                // Update the new range within the existing one.\r\n                range.insertNode(node);\r\n                // Set the selection index at the next available space.\r\n                range.setStart(node.firstChild, 1);\r\n                range.setEnd(node.firstChild, 1);\r\n                // Remove all existing ranges from the selection.\r\n                selection.removeAllRanges();\r\n                // Add the updated range object to the current selection.\r\n                selection.addRange(range);\r\n            }\r\n        } else if (nodeEl) {\r\n            // This means the user is selecting some text that is inside the sub or sup tag.\r\n            // In this case, we only need to move the selected text inside the sub/sup tag outside of it.\r\n            // For example: <sup>123[456]789</sup>. If the selected text is 456, we will\r\n            // move it outside the <sup> tag, resulting in <sup>123</sup>456<sup>789</sup>.\r\n            // Retrieve the selected text.\r\n            // Retrieve the current tag (sub/sup) that wraps the selection\r\n            const selectedText = range.toString();\r\n            const parentElement = nodeEl;\r\n            const nextSibling = parentElement.nextSibling;\r\n            const beforeText = parentElement.textContent.slice(0, range.startOffset);\r\n            const afterText = parentElement.textContent.slice(range.endOffset);\r\n            if (beforeText) {\r\n                const start = this.createElement(parentElement.nodeName.toLowerCase());\r\n                start.textContent = beforeText;\r\n                parentElement.parentNode.insertBefore(start, nextSibling);\r\n            }\r\n            // Create a text node based on the selected text.\r\n            const textNode = document.createTextNode(selectedText);\r\n            parentElement.parentNode.insertBefore(textNode, nextSibling);\r\n            if (afterText) {\r\n                const end = this.createElement(parentElement.nodeName.toLowerCase());\r\n                end.textContent = afterText;\r\n                parentElement.parentNode.insertBefore(end, nextSibling);\r\n            }\r\n\r\n            parentElement.remove();\r\n\r\n            // Create a new range to select the inserted content\r\n            range.setStart(textNode, 0);\r\n            range.setEnd(textNode, selectedText.length);\r\n            selection.removeAllRanges();\r\n            selection.addRange(range);\r\n            this.getTextArea().value = this.getCleanHTML();\r\n        } else {\r\n            // This case is user select a text that is not inside subsup.\r\n            //  We retrieve the selected text and then delete it in DOM.\r\n            const selectedText = range.toString();\r\n            range.deleteContents();\r\n            const previousNode = range.commonAncestorContainer.previousSibling;\r\n            const nextNode = range.commonAncestorContainer.nextSibling;\r\n            // In addition, we will merge adjacent sup/sub tags into a single sup/sub tag.\r\n            if (previousNode || nextNode) {\r\n                const newNode = this.createElement(tag);\r\n                let startOffset = 0;\r\n                let endOffset = 0;\r\n                let content = '';\r\n                if (previousNode && previousNode?.nodeName?.toLowerCase() === tag) {\r\n                    content = previousNode.textContent;\r\n                    startOffset = content.length;\r\n                    previousNode.remove();\r\n                }\r\n                content += selectedText;\r\n                endOffset = content.length;\r\n                if (nextNode && nextNode?.nodeName?.toLowerCase() === tag) {\r\n                    content += nextNode.textContent;\r\n                    nextNode.remove();\r\n                }\r\n                newNode.textContent = content;\r\n                if (content !== selectedText) {\r\n                    range.insertNode(newNode);\r\n                    range.setStart(newNode.firstChild, startOffset);\r\n                    range.setEnd(newNode.firstChild, endOffset);\r\n                    this.getTextArea().value = this.getCleanHTML();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Create a sup/sub tag that wrap the selected text.\r\n            const newNode = document.createElement(tag);\r\n            newNode.appendChild(document.createTextNode(selectedText));\r\n            // Make a selection to the selected text.\r\n            selection.removeAllRanges();\r\n            // Insert it into DOM.\r\n            range.insertNode(newNode);\r\n            range.selectNodeContents(newNode.firstChild);\r\n            selection.addRange(range);\r\n            // Clean up all the empty text.\r\n            this.getEditorContent().childNodes.forEach(el => {\r\n                if(el.nodeName === '#text' && el.textContent === '') {\r\n                    el.remove();\r\n                }\r\n            });\r\n            this.getTextArea().value = this.getCleanHTML();\r\n        }\r\n        // Clean up.\r\n        this.getEditorContent().childNodes.forEach(el => {\r\n            if(el.nodeName === '#text' && el.textContent === '') {\r\n                el.remove();\r\n            }\r\n        });\r\n        this.saveHistory();\r\n    }\r\n\r\n    /**\r\n     * Save history for undo/redo actions.\r\n     */\r\n    saveHistory() {\r\n        const content = this.getCleanHTML();\r\n        if (this.historyIndex === -1 || content !== this.history[this.historyIndex]) {\r\n            this.history.splice(this.historyIndex + 1);\r\n            this.history.push(content);\r\n            this.historyIndex++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cleanup html that comes from WYSIWYG paste events. These are more likely to contain messy code that we should strip.\r\n     *\r\n     * @param {String} content - The content data need to be clean.\r\n     */\r\n    cleanPasteHTML(content) {\r\n        // Return an empty string if passed an invalid or empty object.\r\n        if (!content || content.length === 0) {\r\n            return \"\";\r\n        }\r\n\r\n        // Rules that get rid of the real-nasties and don't care about normalize code (correct quotes, white spaces, etc.).\r\n        let rules = [\r\n            { regex: /<\\s*\\/html\\s*>([\\s\\S]+)$/gi, replace: \"\" },\r\n            { regex: /<!--\\[if[\\s\\S]*?endif\\]-->/gi, replace: \"\" },\r\n            { regex: /<!--(Start|End)Fragment-->/gi, replace: \"\" },\r\n            { regex: /<xml[^>]*>[\\s\\S]*?<\\/xml>/gi, replace: \"\" },\r\n            { regex: /<\\?xml[^>]*>[\\s\\S]*?<\\\\\\?xml>/gi, replace: \"\" },\r\n            { regex: /<\\/?\\w+:[^>]*>/gi, replace: \"\" }\r\n        ];\r\n\r\n        // Apply the first set of harsher rules.\r\n        content = this.filterContentWithRules(content, rules);\r\n\r\n        // Apply the standard rules, which mainly cleans things like headers, links, and style blocks.\r\n        content = this.cleanHTML(content);\r\n\r\n        // Check if the string is empty or only contains whitespace.\r\n        if (content.length === 0 || !/\\S/.test(content)) {\r\n            return content;\r\n        }\r\n\r\n        // Normalize the code by loading it into the DOM.\r\n        const holder = document.createElement('div');\r\n        holder.innerHTML = content;\r\n        content = holder.innerHTML;\r\n\r\n        // Free up the DOM memory.\r\n        holder.innerHTML = \"\";\r\n\r\n        // Run some more rules that care about quotes and whitespace.\r\n        rules = [\r\n            { regex: /(<[^>]*?style\\s*?=\\s*?\"[^>\"]*?)(?:[\\s]*MSO[-:][^>;\"]*;?)+/gi, replace: \"$1\" },\r\n            { regex: /(<[^>]*?class\\s*?=\\s*?\"[^>\"]*?)(?:[\\s]*MSO[_a-zA-Z0-9\\-]*)+/gi, replace: \"$1\" },\r\n            { regex: /(<[^>]*?class\\s*?=\\s*?\"[^>\"]*?)(?:[\\s]*Apple-[_a-zA-Z0-9\\-]*)+/gi, replace: \"$1\" },\r\n            { regex: /<a [^>]*?name\\s*?=\\s*?\"OLE_LINK\\d*?\"[^>]*?>\\s*?<\\/a>/gi, replace: \"\" },\r\n        ];\r\n\r\n        // Apply the rules.\r\n        content = this.filterContentWithRules(content, rules);\r\n\r\n        // Reapply the standard cleaner to the content.\r\n        return this.cleanHTML(content);\r\n    }\r\n\r\n    /**\r\n     * Check if the editor allows the use of sub or sup features.\r\n     *\r\n     * @param {String} action - Sub/sup action to check.\r\n     * @return {Boolean} The result after verifying whether it is allowed.\r\n     */\r\n    isSupportSupSub(action) {\r\n        const { type } = this.settings;\r\n        return type === 'both' || type === action;\r\n    }\r\n\r\n    /**\r\n     * Utility function to filter the content based on the given rules.\r\n     *\r\n     * @param {String} content - The content need to be filtered.\r\n     * @param {Object} rules - The rules list.\r\n     * @return {String} The cleaned content will be returned.\r\n     */\r\n    filterContentWithRules(content, rules) {\r\n        for (const element of rules) {\r\n            content = content.replace(element.regex, element.replace);\r\n        }\r\n        return content;\r\n    }\r\n\r\n    /**\r\n     * Utility function to clean the HTML.\r\n     *\r\n     * @param {String} content - The content need to be filter.\r\n     * @return {String} The cleaned content will be returned.\r\n     */\r\n    cleanHTML(content) {\r\n        // Removing limited things that can break the page or a disallowed, like unclosed comments, style blocks, etc.\r\n\r\n        const rules = [\r\n            //Remove empty paragraphs.\r\n            { regex: /<p[^>]*>(&nbsp;|\\s)*<\\/p>/gi, replace: \"\" },\r\n\r\n            //Remove attributes on sup and sub tags.\r\n            { regex: /<sup[^>]*(&nbsp;|\\s)*>/gi, replace: \"<sup>\" },\r\n            { regex: /<sub[^>]*(&nbsp;|\\s)*>/gi, replace: \"<sub>\" },\r\n\r\n            //Replace &nbsp; with space.\r\n            { regex: /&nbsp;/gi, replace: \" \" },\r\n\r\n            //Combine matching tags with spaces in between.\r\n            { regex: /<\\/sup>(\\s*)+<sup>/gi, replace: \"$1\" },\r\n            { regex: /<\\/sub>(\\s*)+<sub>/gi, replace: \"$1\" },\r\n\r\n            //Move spaces after start sup and sub tags to before.\r\n            { regex: /<sup>(\\s*)+/gi, replace: \"$1<sup>\" },\r\n            { regex: /<sub>(\\s*)+/gi, replace: \"$1<sub>\" },\r\n\r\n            //Move spaces before end sup and sub tags to after.\r\n            { regex: /(\\s*)+<\\/sup>/gi, replace: \"</sup>$1\" },\r\n            { regex: /(\\s*)+<\\/sub>/gi, replace: \"</sub>$1\" },\r\n\r\n            //Remove empty br tags.\r\n            { regex: /<br>/gi, replace: \"\" },\r\n\r\n            // Remove any style blocks. Some browsers do not work well with them in a contenteditable.\r\n            // Plus style blocks are not allowed in body html, except with \"scoped\", which most browsers don't support as of 2015.\r\n            // Reference: \"http://stackoverflow.com/questions/1068280/javascript-regex-multiline-flag-doesnt-work\"\r\n            { regex: /<style[^>]*>[\\s\\S]*?<\\/style>/gi, replace: \"\" },\r\n\r\n            // Remove any open HTML comment opens that are not followed by a close. This can completely break page layout.\r\n            { regex: /<!--(?![\\s\\S]*?-->)/gi, replace: \"\" },\r\n\r\n            // Remove elements that can not contain visible text.\r\n            { regex: /<script[^>]*>[\\s\\S]*?<\\/script>/gi, replace: \"\" },\r\n\r\n            // Source: \"http://www.codinghorror.com/blog/2006/01/cleaning-words-nasty-html.html\"\r\n            // Remove forbidden tags for content, title, meta, style, st0-9, head, font, html, body, link.\r\n            { regex: /<\\/?(?:br|title|meta|style|std|font|html|body|link|a|ul|li|ol)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:b|i|u|ul|ol|li|img)[^>]*?>/gi, replace: \"\" },\r\n            // Source:\"https://developer.mozilla.org/en/docs/Web/HTML/Element\"\r\n            // Remove all elements except sup and sub.\r\n            { regex: /<\\/?(?:abbr|address|area|article|aside|audio|base|bdi|bdo|blockquote)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:button|canvas|caption|cite|code|col|colgroup|content|data)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:datalist|dd|decorator|del|details|dialog|dfn|div|dl|dt|element)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:em|embed|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:h6|header|hgroup|hr|iframe|input|ins|kbd|keygen|label|legend)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:main|map|mark|menu|menuitem|meter|nav|noscript|object|optgroup)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:option|output|p|param|pre|progress|q|rp|rt|rtc|ruby|samp)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:section|select|script|shadow|small|source|std|strong|summary)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:svg|table|tbody|td|template|textarea|time|tfoot|th|thead|tr|track)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:var|wbr|video)[^>]*?>/gi, replace: \"\" },\r\n\r\n            // Deprecated elements that might still be used by older sites.\r\n            { regex: /<\\/?(?:acronym|applet|basefont|big|blink|center|dir|frame|frameset|isindex)[^>]*?>/gi, replace: \"\" },\r\n            { regex: /<\\/?(?:listing|noembed|plaintext|spacer|strike|tt|xmp)[^>]*?>/gi, replace: \"\" },\r\n\r\n            // Elements from common sites including google.com.\r\n            { regex: /<\\/?(?:jsl|nobr)[^>]*?>/gi, replace: \"\" },\r\n\r\n            { regex: /<span(?![^>]*?rangySelectionBoundary[^>]*?)[^>]*>[\\s\\S]*?([\\s\\S]*?)<\\/span>/gi, replace: \"$1\" },\r\n\r\n            // Remove empty spans, but not ones from Rangy.\r\n            { regex: /<span(?![^>]*?rangySelectionBoundary[^>]*?)[^>]*>(&nbsp;|\\s)*<\\/span>/gi, replace: \"\" },\r\n            { regex: /<span(?![^>]*?rangySelectionBoundary[^>]*?)[^>]*>[\\s\\S]*?([\\s\\S]*?)<\\/span>/gi, replace: \"$1\" },\r\n\r\n            // Remove empty sup and sub tags that appear after pasting text.\r\n            { regex: /<sup[^>]*>(&nbsp;|\\s)*<\\/sup>/gi, replace: \"\" },\r\n            { regex: /<sub[^>]*>(&nbsp;|\\s)*<\\/sub>/gi, replace: \"\" },\r\n\r\n            // Remove special xml namespace tag xmlns generate by browser plugin.\r\n            { regex: /<xmlns.*?>(.*?)<\\/xmlns.*?>/gi, replace: \"$1\" },\r\n            { regex: /\\uFEFF/gi, replace: \"\" }\r\n        ];\r\n\r\n        return this.filterContentWithRules(content, rules);\r\n    }\r\n\r\n    /**\r\n     * Clean the generated HTML content without modifying the editor content.\r\n     *\r\n     * This includes removing all YUI IDs from the generated content.\r\n     *\r\n     * @return {string} The cleaned HTML content.\r\n     */\r\n    getCleanHTML() {\r\n        // Clone the editor so that we don't actually modify the real content.\r\n        const editorClone = this.getEditorContent().cloneNode(true);\r\n        let html;\r\n\r\n        html = editorClone.innerHTML;\r\n\r\n        // Define contents that are considered empty.\r\n        const emptyContents = [\r\n            '<p></p>',\r\n            '<p><br></p>',\r\n            '<br>',\r\n            '<p dir=\"rtl\" style=\"text-align: right;\"></p>',\r\n            '<p dir=\"rtl\" style=\"text-align: right;\"><br></p>',\r\n            '<p dir=\"ltr\" style=\"text-align: left;\"></p>',\r\n            '<p dir=\"ltr\" style=\"text-align: left;\"><br></p>',\r\n            '<p>&nbsp;</p>',\r\n            '<p><br>&nbsp;</p>',\r\n            '<p dir=\"rtl\" style=\"text-align: right;\">&nbsp;</p>',\r\n            '<p dir=\"rtl\" style=\"text-align: right;\"><br>&nbsp;</p>',\r\n            '<p dir=\"ltr\" style=\"text-align: left;\">&nbsp;</p>',\r\n            '<p dir=\"ltr\" style=\"text-align: left;\"><br>&nbsp;</p>'\r\n        ];\r\n\r\n        if (emptyContents.includes(html)) {\r\n            return '';\r\n        }\r\n\r\n        // Clean the HTML content.\r\n        return this.cleanHTML(html);\r\n    }\r\n\r\n\r\n    /**\r\n     * Utility function to get the content element of the editor.\r\n     *\r\n     * @return {HTMLElement} The editor content element.\r\n     */\r\n    getEditorContent() {\r\n        return this.getEditor().querySelector(`.${this.settings.classes.content}`);\r\n    }\r\n\r\n    /**\r\n     * Utility function to get the editor element. This element will contain all the components of the editor.\r\n     *\r\n     * @return {HTMLElement} The editor element.\r\n     */\r\n    getEditor() {\r\n        return document.getElementById(`${this.settings.classes.editor}-${this.settings.element}`);\r\n    }\r\n\r\n    /**\r\n     * Utility function to retrieve the button element based on the given type.\r\n     *\r\n     * @param {String} type - The type of the button: sup or sub.\r\n     * @return {HTMLElement} The corresponding button.\r\n     */\r\n    getSupSubButton(type) {\r\n        const { toolbar, button } = this.settings.classes;\r\n        return this.getEditor().querySelector(`.${toolbar} .${button}[data-action^=\"${type}\"]`);\r\n    }\r\n\r\n    /**\r\n     * Utility function to get button settings (sup/sub) based on the given type.\r\n     *\r\n     * @param {String} type - The type of the button can be either sup or sub.\r\n     * @return {Object} The settings for the given button.\r\n     */\r\n    getActions(type) {\r\n        if (defaultActions[type]) {\r\n            return [defaultActions[type]];\r\n        }\r\n\r\n        return Object.values(defaultActions);\r\n    }\r\n\r\n    /**\r\n     * Utility to get the button container for the editor.\r\n     *\r\n     * @return {HTMLElement} The button container.\r\n     */\r\n    getButtonContainer() {\r\n        return this.getEditor().querySelectorAll(`.${this.settings.classes.toolbar} .${this.settings.classes.button}`);\r\n    }\r\n\r\n    /**\r\n     * Utility function to get the content of the original textarea.\r\n     *\r\n     * @return {String} The content.\r\n     */\r\n    getContent() {\r\n        return this.getTextArea().value;\r\n    }\r\n\r\n    /**\r\n     * Utility function to get id of the element.\r\n     *\r\n     * @return {String} The element id.\r\n     */\r\n    getEditorId() {\r\n        return this.settings.element;\r\n    }\r\n\r\n    /**\r\n     * Return the text area element.\r\n     *\r\n     * @return {HTMLElement} Text area element.\r\n     */\r\n    getTextArea() {\r\n        return document.getElementById(this.settings.element);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Load editor based on the given setting.\r\n *\r\n * @param {Object} settings - The editor setting.\r\n */\r\nexport const loadEditor = settings => {\r\n    const editor = new OUSupSubEditor(settings);\r\n    // We need to do this for a specific reason, currently only for the Behat test.\r\n    // We can easily utilize the editor's API.\r\n    if (!window.OUSupSubEditor) {\r\n        window.OUSupSubEditor = {\r\n            instances: {\r\n                [settings.element]: editor,\r\n            },\r\n            addEditor: function (editor) {\r\n                this.instances[editor.getEditorId()] = editor;\r\n            },\r\n            getEditorById: function (editorId) {\r\n                return this.instances[editorId];\r\n            },\r\n        };\r\n    } else {\r\n        window.OUSupSubEditor.addEditor(editor);\r\n    }\r\n};\r\n"],"names":["defaultActions","sup","name","tag","class","sub","OUSupSubEditor","constructor","settings","element","type","classes","wrap","editor","contentWrap","content","toolbar","toolbarGroup","button","custom","document","addEventListener","selection","window","getSelection","this","getEditorContent","contains","anchorNode","node","isSelectionInsideSubSup","setActiveButton","nodeName","toLowerCase","contentElement","createElement","trim","contenteditable","autocapitalize","autocorrect","role","spellcheck","id","replace","event","saveHistory","range","getRangeAt","key","shiftKey","preventDefault","action","nodeEl","setFormat","getActions","isSupportSupSub","ctrlKey","historyIndex","innerHTML","history","getTextArea","value","length","cleanHTML","target","emptyText","createTextNode","insertNode","getCleanHTML","types","clipboardData","isHTML","includes","cleanPasteHTML","getData","cleanData","replaceAll","execCommand","wrapContent","appendChild","Object","assign","defaultSetting","init","textareaElement","style","display","editorElement","editorWrap","toolbarEl","initEditorToolbar","contentElementWrap","initEditorContent","contentEditor","querySelector","width","getAttribute","minWidth","maxWidth","height","heightEditor","lineHeightEditor","minHeight","maxHeight","lineHeight","heightContent","textareaLabel","margin","classList","remove","visibility","marginLeft","parseInt","offsetWidth","parentNode","paddingBottom","verticalAlign","insertAdjacentElement","getContent","requestAnimationFrame","heightWrapper","offsetHeight","e","attributes","attribute","setAttribute","rangeCount","tagName","commonAncestorContainer","isCollapsed","isSupSubTag","nodeNames","selectionNodes","cloneContents","childNodes","textContent","isEqualNode","getEditor","querySelectorAll","forEach","getSupSubButton","add","parent","child","_this$settings","_this$settings$custom2","title","buttons","icon","onclick","blur","focus","_this$settings3","_this$settings3$custo","beforeText","innerText","slice","startOffset","afterText","insertBefore","nextSibling","setStart","setEnd","removeAllRanges","addRange","firstChild","selectedText","toString","parentElement","endOffset","start","textNode","end","deleteContents","previousNode","previousSibling","nextNode","newNode","selectNodeContents","el","splice","push","rules","regex","filterContentWithRules","test","holder","html","cloneNode","getElementById","values","getButtonContainer","getEditorId","addEditor","instances","getEditorById","editorId"],"mappings":"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"}